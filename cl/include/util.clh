#ifndef __UTIL_CLH
#define __UTIL_CLH

#define COORD_2D_INV_Y (int2)(get_global_id(0), get_global_size(1) - get_global_id(1) - 1)

inline float4 hsv2rgb(float3 hsv) {
    const float c = hsv.y * hsv.z;
    const float x = c * (1 - fabs(fmod( hsv.x / 60, 2 ) - 1));
    float3 rgb;
    if      (0 <= hsv.x && hsv.x < 60) {
        rgb = (float3)(c, x, 0);
    } else if (60 <= hsv.x && hsv.x < 120) {
        rgb = (float3)(x, c, 0);
    } else if (120 <= hsv.x && hsv.x < 180) {
        rgb = (float3)(0, c, x);
    } else if (180 <= hsv.x && hsv.x < 240) {
        rgb = (float3)(0, x, c);
    } else if (240 <= hsv.x && hsv.x < 300) {
        rgb = (float3)(x, 0, c);
    } else {
        rgb = (float3)(c, 0, x);
    }
    return (float4)(rgb + (hsv.z - c), 1.0);
}

inline real2 point_from_id(const real4 bounds) {
    const real2 uv = {
        (real)(get_global_id(0) + 0.5) / (real)get_global_size(0),
        (real)(get_global_id(1) + 0.5) / (real)get_global_size(1)
    };
    return bounds.s02 + uv * (bounds.s13 - bounds.s02);
}

inline real2 point_from_id_dense(const real4 bounds) {
    const real2 uv = {
        (real)(get_global_id(0) + 1) / (real)(get_global_size(0)),
        (real)(get_global_id(1) + 1) / (real)(get_global_size(1))
    };
    return bounds.s02 + uv * (bounds.s13 - bounds.s02);
}

// C++ STL pair operator< implementation
inline int pair_lt(const real2 p1, const real2 p2) {
    if (p1.x < p2.x) {
        return 1;
    } else if (p2.x < p1.x) {
        return 0;
    } else if (p1.y < p2.y) {
        return 1;
    } else {
        return 0;
    }
}

#ifndef DETECTION_PRECISION
#define DETECTION_PRECISION 1e-4
#endif

inline int pair_eq(real2 p1, real2 p2) {
    return fabs(p1.x - p2.x) < DETECTION_PRECISION
        && fabs(p1.y - p2.y) < DETECTION_PRECISION;
}

inline int pair_gt(const real2 p1, const real2 p2) {
    return !(pair_lt(p1, p2) || pair_eq(p1, p2));
}

int binary_search(int, const global real*, real2);
int binary_search(int size, const global real* arr, real2 value) {
    int l = 0, r = size;

    while (l < r) {
        const int mid = (r + l) / 2;
        const real2 mid_value = vload2(mid, arr);

        if (pair_eq(mid_value, value)) {
            return mid;
        }
        if (r == l + 1) {
            return -1;
        }
        if (pair_lt(mid_value, value)) {
            l = mid;
        } else {
            r = mid;
        }
    }

    return (r + l) / 2;
}

inline real2 round_point(real2 point, int to_sign) {
    return convert_real2(convert_long2_rtz(point * pow(10.0f, (float)to_sign))) / pow(10.0f, (float)(to_sign));
}

inline real2 round_point_tol(real2 point, real tol) {
    return convert_real2(convert_long2_rtz(point / tol)) * tol;
}

inline float3 hsv_for_count(int count, int total) {
    if (count == total) {
        return (float3)(0.0, 0.0, 0.0);
    }

    const float d = min(1.0, 8.0 / count);

    switch(count % 8) {
        case 1:
            return (float3)(0.00000, 1.00000, d);
        case 2:
            return (float3)(0.33333, 1.00000, d);
        case 3:
            return (float3)(0.66666, 1.00000, d);
        case 4:
            return (float3)(0.83333, 1.00000, d);
        case 5:
            return (float3)(0.16666, 1.00000, d);
        case 6:
            return (float3)(0.50000, 1.00000, d);
        case 7:
            return (float3)(0.83333, 0.66666, d);
        default:
            return count == 8 ? .5 : d;
    }
}

inline float3 color_for_count(int count, int total) {
    return hsv2rgb(hsv_for_count(count, total)).xyz;
}

inline float3 color_for_count_old(int count, int total) {
    if (count == total) {
        return 0.0;
    }
    const float d = 1.0 / count * 8;
    switch(count % 8) {
        case 1:
            return (float3)(1.0, 0.0, 0.0)*d;
        case 2:
            return (float3)(0.0, 1.0, 0.0)*d;
        case 3:
            return (float3)(0.0, 0.0, 1.0)*d;
        case 4:
            return (float3)(1.0, 0.0, 1.0)*d;
        case 5:
            return (float3)(1.0, 1.0, 0.0)*d;
        case 6:
            return (float3)(0.0, 1.0, 1.0)*d;
        case 7:
            return (float3)(0.5, 0.0, 0.0)*d;
        default:
            return count == 8 ? .5 : d;
    }
}

#endif // __UTIL_CLH